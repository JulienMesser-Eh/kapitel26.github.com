<!---------------- SLIDE -------------- -->

<section data-markdown><script type="text/template">
  <aside class="notes">
  Wie sind die Repos aufgebaut?
  Wer ist für was verantwortlich?
  </aside>

Strukturelles
=============

</script></section>




<!---------------- SLIDE -------------- -->

<section data-markdown><script type="text/template">
  <aside class="notes">
  Frage-Folie
  </aside>

**1** großes Repo<br/>oder<br/>viele Kleine?
============================================

</script></section>




<!---------------- SLIDE -------------- -->

<section data-markdown><script type="text/template">
  <aside class="notes">
  Fallbeispiel
  </aside>

Unternehmen: **A, Verwaltung, 1-10 Devs**
-----------------------------------------

Inhouse-Entwicklung mehrerer Anwendungen für Web-Reporting, Laborwertverwaltung und admistrative Tools.

Entscheidung: Repo pro Anwendung
--------------------------------

 * Die Anwendungen sind autark und haben keine direkten Abhängigkeiten.
 * Wiederverwendbare Module sind im eigenem Repo. Einbindung per Gradle.


</script></section>




<!---------------- SLIDE -------------- -->

<section data-markdown><script type="text/template">
  <aside class="notes">
  Fallbeispiel
  </aside>

Unternehmen: **B, Logistik, 20-50 Devs**
-----------------------------------------

 * große modulare Anwendung
 * unabhängig arbeitende Teams
 * gemeinsame Releases
 * Maven Build mit Snapshot-Dependencies

Gemeinsames Release aller Module.

Entscheidung (zunächst): Repo pro Modul
--------------------------------

Es zeigte sich, dass der Verwaltungs- und Koordinationsaufwand für Repos und Branches recht hoch war.

<!--
TODO: Präziser wäre gut.
VORSCHLSGL Welche Module in welchen Versionen sollen ausgeliefert werden?
TODO: Sind Modulübergreifende Änderungen Teil die Ursache?

Ursachen:
 * Branch/Tags anlegen in allen Repos
 * Commits per Repo bei übergreifenden Änderungen
-->

Entscheidung (revidiert): 1 Repo
--------------------------------

VORSCHLAG: Release-Vorbereitungen vereinfacht. Es ist klar, was rausgehen soll, und was zu testen ist.

</script></section>


<!-- TODO evtl. C Finanzen -->


<!---------------- SLIDE -------------- -->

<section data-markdown><script type="text/template">
  <aside class="notes">
  Fallbeispiel

  Problem bei Subtrees: Sehr viel Subtree-Merge-Commits bei jeder täglichen Integration. (> 30 Minuten). Mit read-tree-Lösung (< 2 Minuten).
  </aside>

Unternehmen: **D, Versicherung, 100+ Devs**
-----------------------------------------

 * etliche Teams
 * viel Module (>100)
 * komplexe Fachlichkeit, viele Abhängigkeiten
 * seltene übergreifende Releases

Gemeinsames Release aller Module.

Entscheidung: Repo pro Modul
--------------------------------

Separate Release-Planung pro Modul möglich (eigene Branches).
Separate Freigaben von Änderungen pro Modul.
Historie für die Teams übersichtlicher.

Entscheidung (zusätzlich): Globales Repo mit Subtrees
--------------------------------

Übergreifende Historisierung, Nachvollziehbarkeit, globales Release und Revisionssicherheit. Täglich zusammengeführte Basis für alle Entwicklungen.

Zwei Varianten: Subtree vs. read-tree

</script></section>

<!-- TODO evtl. E embedded -->


<!---------------- SLIDE -------------- -->

<section data-markdown><script type="text/template">
  <aside class="notes">
  Frage-Folie

  Diese Frage ist vor allem dann relevant, wenn die Antwort auf die
  vorige Frage "viele Repos" lautet.

  Dann stellt sich dir Frage, wie gewährleistet man einen konsistenten
  Stand, wenn Änderungen mehrerer Module betreffen.
  </aside>

Repo-Abhängigkeiten
-------------------

**in Git**<br/>oder<br/>**extern**?
===================================

Subrepo/Submodule vs. Gradle, Maven & Co.

</script></section>

<!---------------- SLIDE -------------- -->

<section data-markdown><script type="text/template">
  <aside class="notes">
  </aside>

Repo-Abhängigkeiten
-------------------

* die meisten befragten Unternehmen arbeiten mit externen Abhängigkeiten (Ausnahme D-Versicherung, die teilweise mit Subtrees arbeitet)
* Git Submodule und Subtrees sind komplexer nd nicht so flexibel wie externe Werkzeuge

</script></section>



<!---------------- SLIDE -------------- -->

<section data-markdown><script type="text/template">
  <aside class="notes">
  Frage-Folie
  </aside>

Administration
==============

Wer macht was?
--------------

</script></section>




<!---------------- SLIDE -------------- -->

<section data-markdown><script type="text/template">
  <aside class="notes">
  Frage-Folie
  </aside>

Berechtigungen
==============

Wer darf was?
-------------

</script></section>





<!---------------- SLIDE -------------- -->

<section data-markdown><script type="text/template">
  <aside class="notes">
  Frage-Folie
  </aside>

Wer bestimmt, was ins Repo kommt?
---------------------------------

Push<br/>oder<br/>Pull?
=======================

</script></section>



<!---------------- SLIDE -------------- -->

<section data-markdown><script type="text/template">
  <aside class="notes">
  Frage-Folie
  </aside>

Pull-Requests
=============

![Pull-Request-1](pull-requests-1.png)
![Pull-Request-2](pull-requests-2.png)

</script></section>




<!---------------- SLIDE -------------- -->

<section data-markdown><script type="text/template">
  <aside class="notes">
  Fallbeispiel
  </aside>

Unternehmen: **D, Versicherung, 100+ Devs**
-----------------------------------------

 * etliche Teams
 * viele Module (>100)
 * komplexe Fachlichkeit, viele Abhängigkeiten
 * seltene übergreifende Releases

Gemeinsames Release aller Module.

Entscheidung: Pull-Requests
---------------------------

Nicht der Entwickler, sondern Leitung bestimmt, ob und wann etwas übernommen wird.

</script></section>




<!---------------- SLIDE -------------- -->

<section data-markdown><script type="text/template">
  <aside class="notes">
  Fallbeispiel
  </aside>

Unternehmen: **F, Finanzen, 10-20 Devs**
-----------------------------------------

Entwickeln Payment-Software in mehreren Teams.

Entscheidung: Pull-Requests
---------------------------

Durch Pull-Requests wird garantiert, dass keine Änderung direkt vom Entwickler ins Hauptrepo wandert. Erst nach einem Code-Revew.

</script></section>
